#!/bin/bash
# =============================================================================
# test.sh - Unified testing for {{ project_name }}
# =============================================================================
# Generated by SpecInit - https://github.com/Geoffe-Ga/specinit
#
# Runs configured test frameworks:
{% if has_python %}#   - Python: pytest with coverage
{% endif %}{% if has_frontend %}#   - Frontend: npm test (vitest, jest, etc.)
{% endif %}#
# Usage:
#   ./scripts/test.sh [options] [test_paths...] [-- extra_args...]
#
# Options:
#   --verbose, -v      Show detailed output
#   --quiet, -q        Minimal output
#   --no-cov           Skip coverage reporting
{% if has_python and has_frontend %}#   --python           Run Python tests only
#   --frontend         Run frontend tests only
{% endif %}{% if has_python %}#   --pattern, -k      Run tests matching pattern (pytest -k)
#   --marker, -m       Run tests with marker (pytest -m)
#   --failed           Re-run only failed tests (pytest --lf)
{% endif %}#   --help, -h         Show this help message
#
# =============================================================================

set -eo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/lib/common.sh"
source "${SCRIPT_DIR}/lib/detect.sh"

# =============================================================================
# Configuration
# =============================================================================

{% if has_python and has_frontend %}PYTHON_ONLY=false
FRONTEND_ONLY=false
{% endif %}NO_COVERAGE=false
{% if has_python %}TEST_PATTERN=""
TEST_MARKER=""
FAILED_ONLY=false
{% endif %}TEST_PATHS=()
EXTRA_ARGS=()
ERRORS=0
START_TIME=$(date +%s)

# =============================================================================
# Help
# =============================================================================

show_help() {
    cat << 'EOF'
test.sh - Unified testing for {{ project_name }}

USAGE:
    ./scripts/test.sh [OPTIONS] [TEST_PATHS...] [-- EXTRA_ARGS...]

OPTIONS:
    --verbose, -v      Show detailed output
    --quiet, -q        Minimal output
    --no-cov           Skip coverage reporting
{% if has_python and has_frontend %}    --python           Run Python tests only
    --frontend         Run frontend tests only
{% endif %}{% if has_python %}    --pattern, -k      Run tests matching pattern (pytest -k)
    --marker, -m       Run tests with marker (pytest -m)
    --failed           Re-run only failed tests (pytest --lf)
{% endif %}    --help, -h         Show this help message
{% if has_python %}
TEST PATHS:
    tests/unit/test_cli.py                              # Specific file
    tests/unit/test_cli.py::TestInitCommand             # Specific class
    tests/unit/test_cli.py::TestInitCommand::test_init  # Specific test
{% endif %}
EXAMPLES:
    ./scripts/test.sh                                   # Run all tests
{% if has_python %}    ./scripts/test.sh tests/unit/test_cli.py           # Run specific file
    ./scripts/test.sh -k "test_config"                 # Pattern match
    ./scripts/test.sh --failed                         # Re-run failed tests
    ./scripts/test.sh -- -x --pdb                      # Pass args to pytest
{% endif %}EOF
}

# =============================================================================
# Argument Parsing
# =============================================================================

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --verbose|-v)
                VERBOSE=true
                shift
                ;;
            --quiet|-q)
                QUIET=true
                shift
                ;;
            --no-cov)
                NO_COVERAGE=true
                shift
                ;;
{% if has_python and has_frontend %}            --python)
                PYTHON_ONLY=true
                shift
                ;;
            --frontend)
                FRONTEND_ONLY=true
                shift
                ;;
{% endif %}{% if has_python %}            --pattern|-k)
                TEST_PATTERN="$2"
                shift 2
                ;;
            --marker|-m)
                TEST_MARKER="$2"
                shift 2
                ;;
            --failed)
                FAILED_ONLY=true
                shift
                ;;
{% endif %}            --help|-h)
                show_help
                exit 0
                ;;
            --)
                shift
                EXTRA_ARGS=("$@")
                break
                ;;
            -*)
                log_error "Unknown option: $1"
                exit $EXIT_INVALID_ARGS
                ;;
            *)
                TEST_PATHS+=("$1")
                shift
                ;;
        esac
    done
}

# =============================================================================
# Testing Functions
# =============================================================================
{% if has_python %}

test_python() {
    if ! detect_python; then
        log_debug "No Python project detected, skipping"
        return 0
    fi

    if ! detect_pytest; then
        log_debug "Pytest not configured, skipping"
        return 0
    fi

    log_step "Python Tests"

    if ! python -m pytest --version &>/dev/null; then
        log_error "pytest not installed"
        return 1
    fi

    local pytest_args=()

    # Verbosity
    if [[ "$VERBOSE" == true ]]; then
        pytest_args+=("-v" "--tb=long")
    elif [[ "$QUIET" == true ]]; then
        pytest_args+=("-q" "--tb=short")
    else
        pytest_args+=("-v" "--tb=short")
    fi

    # Coverage
    if [[ "$NO_COVERAGE" != true ]]; then
        local cov_source
        cov_source=$(get_python_src_dirs | head -n1)
        if [[ -n "$cov_source" ]]; then
            pytest_args+=("--cov=$cov_source" "--cov-report=term-missing")
        fi
    fi

    # Pattern matching
    [[ -n "$TEST_PATTERN" ]] && pytest_args+=("-k" "$TEST_PATTERN")

    # Marker filtering
    [[ -n "$TEST_MARKER" ]] && pytest_args+=("-m" "$TEST_MARKER")

    # Failed only
    [[ "$FAILED_ONLY" == true ]] && pytest_args+=("--lf")

    # Test paths
    if [[ ${#TEST_PATHS[@]} -gt 0 ]]; then
        pytest_args+=("${TEST_PATHS[@]}")
    else
        local test_dirs
        test_dirs=$(get_python_test_dirs)
        [[ -n "$test_dirs" ]] && pytest_args+=($test_dirs)
    fi

    # Extra arguments
    [[ ${#EXTRA_ARGS[@]} -gt 0 ]] && pytest_args+=("${EXTRA_ARGS[@]}")

    log_info "Running pytest..."
    if python -m pytest "${pytest_args[@]}"; then
        log_success "All Python tests passed"
    else
        log_error "Python tests failed"
        ((ERRORS++))
    fi
}
{% endif %}
{% if has_frontend %}

test_frontend() {
    if ! detect_frontend; then
        log_debug "No frontend project detected, skipping"
        return 0
    fi

    log_step "Frontend Tests"

    local frontend_dir
    frontend_dir=$(get_frontend_dir)

    if [[ -z "$frontend_dir" ]] || [[ ! -d "$frontend_dir" ]]; then
        log_warn "Frontend directory not found"
        return 0
    fi

    if ! grep -q '"test"' "${frontend_dir}/package.json" 2>/dev/null; then
        log_warn "No test script configured in package.json"
        return 0
    fi

    pushd "$frontend_dir" > /dev/null

    log_info "Running frontend tests..."

    local test_cmd="npm test"
    [[ "$QUIET" == true ]] && test_cmd="$test_cmd -- --silent"
    [[ "$VERBOSE" == true ]] && test_cmd="$test_cmd -- --verbose"

    if eval "$test_cmd"; then
        log_success "All frontend tests passed"
    else
        log_error "Frontend tests failed"
        ((ERRORS++))
    fi

    popd > /dev/null
}
{% endif %}

# =============================================================================
# Main
# =============================================================================

main() {
    setup_colors
    parse_args "$@"

    log_info "Starting test suite..."
{% if has_python and has_frontend %}
    [[ "$FRONTEND_ONLY" != true ]] && test_python
    [[ "$PYTHON_ONLY" != true ]] && test_frontend
{% elif has_python %}
    test_python
{% elif has_frontend %}
    test_frontend
{% endif %}

    local end_time duration
    end_time=$(date +%s)
    duration=$((end_time - START_TIME))

    log_summary "Test Summary"

    if [[ $ERRORS -eq 0 ]]; then
        log_success "All tests passed! ($(format_duration $duration))"
        exit $EXIT_SUCCESS
    else
        log_error "$ERRORS test suite(s) failed ($(format_duration $duration))"
        exit $EXIT_TEST_FAIL
    fi
}

main "$@"
