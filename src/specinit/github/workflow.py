"""GitHub workflow orchestration for issue-driven development."""

import asyncio
import re
import subprocess
from collections.abc import Callable, Coroutine
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any

from specinit.github.service import (
    GitHubService,
    Issue,
    PullRequest,
    create_branch,
    push_branch,
)

ProgressCallback = Callable[[str, str, dict | None], Coroutine[Any, Any, None]]


class IssueStatus(Enum):
    """Status of an issue in the workflow."""

    QUEUED = "queued"
    IN_PROGRESS = "in_progress"
    PRECOMMIT_FAILED = "precommit_failed"
    PRECOMMIT_FIXING = "precommit_fixing"
    PR_CREATED = "pr_created"
    CI_RUNNING = "ci_running"
    CI_FAILED = "ci_failed"
    CI_FIXING = "ci_fixing"
    COVERAGE_FAILED = "coverage_failed"
    COVERAGE_FIXING = "coverage_fixing"
    IN_REVIEW = "in_review"
    CHANGES_REQUESTED = "changes_requested"
    REVIEW_FIXING = "review_fixing"
    APPROVED = "approved"
    MERGED = "merged"
    BLOCKED = "blocked"
    FAILED = "failed"


@dataclass
class WorkflowIssue:
    """An issue being tracked in the workflow."""

    issue: Issue
    status: IssueStatus = IssueStatus.QUEUED
    branch_name: str = ""
    pr: PullRequest | None = None
    dependencies: list[int] = field(default_factory=list)
    fix_attempts: int = 0
    error_message: str = ""


@dataclass
class CoverageThresholds:
    """Coverage thresholds for different module types."""

    overall: int = 90  # Overall minimum coverage
    logic: int = 90  # Logic-heavy modules (generators, services, etc.)
    ui: int = 60  # Frontend/UI components (realistic for UI)
    tests: int = 0  # Test files themselves (excluded from coverage)


@dataclass
class GitHubConfig:
    """Configuration for GitHub workflow."""

    owner: str
    repo: str
    base_branch: str = "main"
    auto_merge: bool = True
    yolo_mode: bool = False
    max_fix_attempts: int = 5
    parallel_branches: int = 3
    # Iteration settings
    iterate_on_precommit: bool = True  # Retry pre-commit failures
    iterate_on_ci: bool = True  # Retry CI failures
    iterate_on_coverage: bool = True  # Retry coverage failures
    claude_code_review: bool = False  # Include Claude Code reviews in YOLO mode
    coverage_thresholds: CoverageThresholds = field(default_factory=CoverageThresholds)
    ci_timeout_seconds: int = 600  # 10 minutes
    review_poll_interval: int = 30  # Seconds between review checks


class GitHubWorkflow:
    """Orchestrates issue-driven development workflow."""

    def __init__(
        self,
        config: GitHubConfig,
        project_path: Path,
        github_service: GitHubService | None = None,
    ) -> None:
        """Initialize the workflow."""
        self.config = config
        self.project_path = project_path
        self.github = github_service or GitHubService()
        self.issues: dict[int, WorkflowIssue] = {}
        self.milestone_number: int | None = None

    async def setup_repository(self) -> None:
        """Set up the repository with labels and milestone."""
        # Create labels
        labels = [
            ("specinit", "7057ff", "Generated by SpecInit"),
            ("automated", "0e8a16", "Automated PR"),
            ("setup", "c5def5", "Setup and configuration"),
            ("feature", "a2eeef", "New feature"),
            ("docs", "0075ca", "Documentation"),
            ("test", "d4c5f9", "Tests"),
            ("ci", "fbca04", "CI/CD"),
        ]

        for name, color, description in labels:
            self.github.create_label(self.config.owner, self.config.repo, name, color, description)

    async def create_milestone(self, title: str, description: str = "") -> int:
        """Create a milestone for the project."""
        self.milestone_number = self.github.create_milestone(
            self.config.owner, self.config.repo, title, description
        )
        return self.milestone_number

    async def create_issues_from_spec(
        self,
        _spec_content: str,
        features: list[str],
        user_story: dict[str, str],
    ) -> list[Issue]:
        """Create GitHub issues based on the product spec."""
        created_issues: list[Issue] = []

        # Standard setup issues
        setup_issues: list[tuple[str, str, list[str]]] = [
            (
                "[Setup] Initialize project structure",
                self._format_setup_issue_body(
                    "Create the initial directory structure and placeholder files."
                ),
                ["specinit", "automated", "setup"],
            ),
            (
                "[Docs] Create README and documentation",
                self._format_docs_issue_body(),
                ["specinit", "automated", "docs"],
            ),
            (
                "[Config] Configure linters and pre-commit hooks",
                self._format_config_issue_body(),
                ["specinit", "automated", "setup"],
            ),
            (
                "[CI] Set up GitHub Actions workflow",
                self._format_ci_issue_body(),
                ["specinit", "automated", "ci"],
            ),
        ]

        # Create setup issues
        for title, body, labels in setup_issues:
            issue = self.github.create_issue(
                self.config.owner,
                self.config.repo,
                title=title,
                body=body,
                labels=labels,
                milestone=self.milestone_number,
            )
            created_issues.append(issue)
            self.issues[issue.number] = WorkflowIssue(
                issue=issue,
                dependencies=[],
            )

        # Create feature issues
        setup_issue_numbers = [i.number for i in created_issues]
        for feature in features:
            issue = self.github.create_issue(
                self.config.owner,
                self.config.repo,
                title=f"[Feature] {feature}",
                body=self._format_feature_issue_body(feature, user_story),
                labels=["specinit", "automated", "feature"],
                milestone=self.milestone_number,
            )
            created_issues.append(issue)
            self.issues[issue.number] = WorkflowIssue(
                issue=issue,
                dependencies=setup_issue_numbers.copy(),
            )

        # Create final test issue (depends on features)
        feature_issue_numbers = [i.number for i in created_issues if "[Feature]" in i.title]
        test_issue = self.github.create_issue(
            self.config.owner,
            self.config.repo,
            title="[Test] Write integration tests",
            body=self._format_test_issue_body(features),
            labels=["specinit", "automated", "test"],
            milestone=self.milestone_number,
        )
        created_issues.append(test_issue)
        self.issues[test_issue.number] = WorkflowIssue(
            issue=test_issue,
            dependencies=feature_issue_numbers,
        )

        return created_issues

    def _format_setup_issue_body(self, description: str) -> str:
        """Format setup issue body."""
        return f"""## Initialize Project Structure

### Description
{description}

### Tasks
- [ ] Create directory tree per template
- [ ] Add .gitignore
- [ ] Create plan/ directory with spec files
- [ ] Add package.json / pyproject.toml

### Acceptance Criteria
- All directories exist
- No linter errors on structure
- plan/product-spec.md present
"""

    def _format_docs_issue_body(self) -> str:
        """Format documentation issue body."""
        return """## Create Documentation

### Description
Write comprehensive documentation for the project.

### Tasks
- [ ] Create README.md with quick start guide
- [ ] Create CONTRIBUTING.md with development workflow
- [ ] Create CLAUDE.md with AI context
- [ ] Add architecture documentation

### Acceptance Criteria
- README includes installation and usage
- Contributing guide covers testing workflow
- CLAUDE.md documents key decisions
"""

    def _format_config_issue_body(self) -> str:
        """Format config issue body."""
        return """## Configure Developer Tooling

### Description
Set up linters, formatters, and pre-commit hooks.

### Tasks
- [ ] Configure ESLint/Ruff
- [ ] Configure Prettier/Black
- [ ] Set up pre-commit hooks
- [ ] Verify all tools work together

### Acceptance Criteria
- Linters pass on all files
- Pre-commit hooks run successfully
- Tools are properly integrated
"""

    def _format_ci_issue_body(self) -> str:
        """Format CI issue body."""
        return """## Set Up CI/CD

### Description
Configure GitHub Actions for continuous integration.

### Tasks
- [ ] Create CI workflow for tests
- [ ] Create workflow for linting
- [ ] Configure caching for dependencies
- [ ] Add status badges to README

### Acceptance Criteria
- CI runs on all PRs
- Tests and linters execute
- Workflows complete successfully
"""

    def _format_feature_issue_body(self, feature: str, user_story: dict[str, str]) -> str:
        """Format feature issue body."""
        return f"""## Implement: {feature}

### Description
Implement the {feature} feature.

### User Story
As {user_story.get("role", "a user")}, I want to {user_story.get("action", "use this feature")}, so that {user_story.get("outcome", "I can achieve my goal")}.

### Tasks
- [ ] Write tests first (TDD)
- [ ] Implement feature
- [ ] Update documentation
- [ ] Verify all tests pass

### Acceptance Criteria
- Feature works as described
- Tests cover happy path and edge cases
- Documentation updated
"""

    def _format_test_issue_body(self, features: list[str]) -> str:
        """Format test issue body."""
        feature_list = "\n".join(f"- {f}" for f in features)
        return f"""## Write Integration Tests

### Description
Create comprehensive integration tests for all features.

### Features to Test
{feature_list}

### Tasks
- [ ] Write end-to-end tests
- [ ] Test feature interactions
- [ ] Test error scenarios
- [ ] Achieve coverage targets

### Acceptance Criteria
- All integration tests pass
- Coverage meets targets
- Error scenarios handled
"""

    def get_ready_issues(self) -> list[WorkflowIssue]:
        """Get issues that are ready to be worked on."""
        ready = []

        for workflow_issue in self.issues.values():
            if workflow_issue.status != IssueStatus.QUEUED:
                continue

            # Check if all dependencies are merged
            deps_satisfied = all(
                self.issues.get(dep, WorkflowIssue(issue=Issue(0, "", "", []))).status
                == IssueStatus.MERGED
                for dep in workflow_issue.dependencies
            )

            if deps_satisfied:
                ready.append(workflow_issue)

        return ready

    async def work_on_issue(
        self,
        workflow_issue: WorkflowIssue,
        implementation_callback: Callable[[Issue], Coroutine[Any, Any, None]],
        progress_callback: ProgressCallback | None = None,
    ) -> None:
        """Work on a single issue through the full workflow.

        This method orchestrates the complete issue workflow with iteration:
        1. Create branch and implement
        2. Run pre-commit hooks (iterate until green or max attempts)
        3. Create PR and run CI (iterate until green or max attempts)
        4. Check coverage thresholds (iterate if below threshold)
        5. Handle reviews (iterate in YOLO mode, including Claude Code reviews)
        6. Merge when approved
        """
        issue = workflow_issue.issue
        workflow_issue.status = IssueStatus.IN_PROGRESS

        if progress_callback:
            await progress_callback(
                f"issue_{issue.number}",
                "in_progress",
                {"title": issue.title},
            )

        # Create branch
        branch_name = f"issue-{issue.number}-{self._slugify(issue.title)}"
        workflow_issue.branch_name = branch_name

        try:
            create_branch(branch_name, self.config.base_branch)
        except subprocess.CalledProcessError:
            # Branch might already exist
            subprocess.run(["git", "checkout", branch_name], check=True)

        # Implementation (provided by caller)
        await implementation_callback(issue)

        # Run pre-commit with iteration
        precommit_success = await self._iterate_precommit(
            workflow_issue, implementation_callback, progress_callback
        )
        if not precommit_success:
            workflow_issue.status = IssueStatus.FAILED
            return

        # Commit and push
        subprocess.run(
            ["git", "add", "."],
            cwd=self.project_path,
            check=True,
        )
        subprocess.run(
            [
                "git",
                "commit",
                "-m",
                f"feat: {issue.title}\n\nCloses #{issue.number}",
            ],
            cwd=self.project_path,
            check=True,
        )
        push_branch(branch_name)

        # Create PR
        pr = self.github.create_pull_request(
            self.config.owner,
            self.config.repo,
            title=issue.title.replace("[", "").replace("]", ": ").strip(),
            body=f"## Summary\n\n{issue.body}\n\nCloses #{issue.number}",
            head=branch_name,
            base=self.config.base_branch,
        )
        workflow_issue.pr = pr
        workflow_issue.status = IssueStatus.PR_CREATED

        if progress_callback:
            await progress_callback(
                f"issue_{issue.number}",
                "pr_created",
                {"pr_url": pr.url, "pr_number": pr.number},
            )

        # Wait for CI with iteration on failures
        ci_success = await self._iterate_ci(
            workflow_issue, implementation_callback, progress_callback
        )
        if not ci_success:
            workflow_issue.status = IssueStatus.FAILED
            return

        # If YOLO mode, handle reviews (including Claude Code reviews if enabled)
        if self.config.yolo_mode:
            await self._handle_reviews(workflow_issue, implementation_callback, progress_callback)

        # Merge if ready
        if self.config.auto_merge and workflow_issue.status == IssueStatus.APPROVED:
            success = self.github.merge_pull_request(
                self.config.owner,
                self.config.repo,
                pr.number,
            )
            if success:
                workflow_issue.status = IssueStatus.MERGED
                if progress_callback:
                    await progress_callback(
                        f"issue_{issue.number}",
                        "merged",
                        {"pr_number": pr.number},
                    )

    async def _run_precommit(self, workflow_issue: WorkflowIssue) -> bool:
        """Run pre-commit hooks and return success status."""
        result = subprocess.run(
            ["pre-commit", "run", "--all-files"],
            cwd=self.project_path,
            capture_output=True,
            text=True,
            check=False,
        )

        if result.returncode == 0:
            return True

        workflow_issue.fix_attempts += 1
        workflow_issue.error_message = result.stdout + result.stderr
        return False

    async def _iterate_precommit(
        self,
        workflow_issue: WorkflowIssue,
        implementation_callback: Callable[[Issue], Coroutine[Any, Any, None]],
        progress_callback: ProgressCallback | None = None,
    ) -> bool:
        """Iterate on pre-commit failures until green or max attempts.

        Returns True if pre-commit eventually passes, False if max attempts exceeded.
        """
        if not self.config.iterate_on_precommit:
            # Just run once without iteration
            return await self._run_precommit(workflow_issue)

        attempt = 0
        while attempt < self.config.max_fix_attempts:
            success = await self._run_precommit(workflow_issue)
            if success:
                return True

            attempt += 1
            workflow_issue.status = IssueStatus.PRECOMMIT_FIXING

            if progress_callback:
                await progress_callback(
                    f"issue_{workflow_issue.issue.number}",
                    "precommit_fixing",
                    {
                        "attempt": attempt,
                        "max_attempts": self.config.max_fix_attempts,
                        "error": workflow_issue.error_message[:500],
                    },
                )

            if attempt >= self.config.max_fix_attempts:
                workflow_issue.status = IssueStatus.PRECOMMIT_FAILED
                return False

            # Call implementation callback to fix the issues
            await implementation_callback(workflow_issue.issue)

            # Stage any auto-fixes from pre-commit
            subprocess.run(["git", "add", "."], cwd=self.project_path, check=False)

        return False

    async def _iterate_ci(
        self,
        workflow_issue: WorkflowIssue,
        implementation_callback: Callable[[Issue], Coroutine[Any, Any, None]],
        progress_callback: ProgressCallback | None = None,
    ) -> bool:
        """Iterate on CI failures until green or max attempts.

        This handles:
        1. CI check failures (tests, linting, type checking)
        2. Coverage threshold failures
        3. Any other CI workflow failures

        Returns True if CI eventually passes, False if max attempts exceeded.
        """
        attempt = 0
        while attempt < self.config.max_fix_attempts:
            # Wait for CI to complete
            await self._wait_for_ci(workflow_issue, progress_callback)

            if workflow_issue.status == IssueStatus.IN_REVIEW:
                # CI passed, check coverage if enabled
                if self.config.iterate_on_coverage:
                    coverage_ok = await self._check_coverage(workflow_issue, progress_callback)
                    if not coverage_ok:
                        attempt += 1
                        if attempt >= self.config.max_fix_attempts:
                            workflow_issue.status = IssueStatus.COVERAGE_FAILED
                            return False

                        workflow_issue.status = IssueStatus.COVERAGE_FIXING
                        if progress_callback:
                            await progress_callback(
                                f"issue_{workflow_issue.issue.number}",
                                "coverage_fixing",
                                {"attempt": attempt},
                            )

                        # Call implementation callback to add tests
                        await implementation_callback(workflow_issue.issue)
                        await self._commit_and_push_fix(
                            workflow_issue, "fix: improve test coverage"
                        )
                        continue

                return True

            if workflow_issue.status == IssueStatus.CI_FAILED:
                if not self.config.iterate_on_ci:
                    return False

                attempt += 1
                if attempt >= self.config.max_fix_attempts:
                    return False

                workflow_issue.status = IssueStatus.CI_FIXING

                if progress_callback:
                    # Get failure details from CI
                    failure_info = await self._get_ci_failure_info(workflow_issue)
                    await progress_callback(
                        f"issue_{workflow_issue.issue.number}",
                        "ci_fixing",
                        {
                            "attempt": attempt,
                            "max_attempts": self.config.max_fix_attempts,
                            "failures": failure_info,
                        },
                    )

                # Call implementation callback to fix CI failures
                await implementation_callback(workflow_issue.issue)
                await self._commit_and_push_fix(workflow_issue, "fix: address CI failures")

            else:
                # Unknown state
                return False

        return False

    async def _check_coverage(
        self,
        workflow_issue: WorkflowIssue,
        progress_callback: ProgressCallback | None = None,
    ) -> bool:
        """Check if coverage thresholds are met.

        Returns True if coverage is acceptable, False otherwise.
        """
        pr = workflow_issue.pr
        if not pr:
            return True  # Can't check without PR

        # Get coverage info from CI checks (codecov, coverage report, etc.)
        checks = self.github.get_pr_checks(
            self.config.owner, self.config.repo, workflow_issue.branch_name
        )

        check_runs = checks.get("check_runs", [])
        for run in check_runs:
            name = run.get("name", "").lower()
            if "coverage" in name or "codecov" in name:
                conclusion = run.get("conclusion")
                if conclusion == "failure":
                    workflow_issue.status = IssueStatus.COVERAGE_FAILED
                    if progress_callback:
                        await progress_callback(
                            f"issue_{workflow_issue.issue.number}",
                            "coverage_failed",
                            {"check_name": run.get("name")},
                        )
                    return False

        return True

    async def _get_ci_failure_info(self, _workflow_issue: WorkflowIssue) -> list[dict[str, str]]:
        """Get details about CI failures from workflow logs."""
        # Workflow run ID would need to be tracked separately
        # For now, we rely on the progress callback to provide failure context
        # from the CI checks themselves
        return []

    async def _commit_and_push_fix(self, workflow_issue: WorkflowIssue, message: str) -> None:
        """Commit and push fixes for a workflow issue."""
        subprocess.run(["git", "add", "."], cwd=self.project_path, check=True)

        # Check if there are changes to commit
        result = subprocess.run(
            ["git", "diff", "--staged", "--quiet"],
            cwd=self.project_path,
            check=False,
        )
        if result.returncode == 0:
            # No changes to commit
            return

        subprocess.run(
            ["git", "commit", "-m", message],
            cwd=self.project_path,
            check=False,
        )
        push_branch(workflow_issue.branch_name, force=False)

    async def _wait_for_ci(
        self,
        workflow_issue: WorkflowIssue,
        progress_callback: ProgressCallback | None = None,
    ) -> None:
        """Wait for CI checks to complete."""
        workflow_issue.status = IssueStatus.CI_RUNNING
        pr = workflow_issue.pr
        if not pr:
            return

        if progress_callback:
            await progress_callback(
                f"issue_{workflow_issue.issue.number}",
                "ci_running",
                {"pr_number": pr.number},
            )

        max_wait = 600  # 10 minutes
        interval = 15
        elapsed = 0

        while elapsed < max_wait:
            checks = self.github.get_pr_checks(
                self.config.owner, self.config.repo, workflow_issue.branch_name
            )

            check_runs = checks.get("check_runs", [])
            if not check_runs:
                await asyncio.sleep(interval)
                elapsed += interval
                continue

            all_complete = all(run.get("status") == "completed" for run in check_runs)
            all_success = all(run.get("conclusion") in ("success", "skipped") for run in check_runs)

            if all_complete:
                if all_success:
                    workflow_issue.status = IssueStatus.IN_REVIEW
                    return
                else:
                    workflow_issue.status = IssueStatus.CI_FAILED
                    if progress_callback:
                        await progress_callback(
                            f"issue_{workflow_issue.issue.number}",
                            "ci_failed",
                            {"pr_number": pr.number},
                        )
                    return

            await asyncio.sleep(interval)
            elapsed += interval

        workflow_issue.status = IssueStatus.CI_FAILED

    async def _handle_reviews(
        self,
        workflow_issue: WorkflowIssue,
        implementation_callback: Callable[[Issue], Coroutine[Any, Any, None]],
        progress_callback: ProgressCallback | None = None,
    ) -> None:
        """Handle review comments in YOLO mode.

        This iterates on:
        1. Human reviewer feedback (CHANGES_REQUESTED, unresolved comments)
        2. Claude Code reviews (if claude_code_review is enabled in config)

        Continues until:
        - All reviewers approve (LGTM)
        - Max fix attempts exceeded
        """
        pr = workflow_issue.pr
        if not pr:
            return

        review_attempt = 0
        while review_attempt < self.config.max_fix_attempts:
            # Get reviews and comments
            reviews = self.github.get_pr_reviews(self.config.owner, self.config.repo, pr.number)
            comments = self.github.get_pr_comments(self.config.owner, self.config.repo, pr.number)

            # Check for human approvals
            human_approved = any(r.get("state") == "APPROVED" for r in reviews)

            # Check for Claude Code review status (if enabled)
            claude_approved = True
            claude_feedback: list[str] = []
            if self.config.claude_code_review:
                claude_approved, claude_feedback = self._check_claude_code_review(reviews, comments)

            # If all reviewers approve, we're done
            if human_approved and claude_approved:
                workflow_issue.status = IssueStatus.APPROVED
                return

            # Check for change requests from any reviewer
            changes_requested = any(r.get("state") == "CHANGES_REQUESTED" for r in reviews)
            unresolved_comments = [c for c in comments if not c.get("resolved", False)]

            # Include Claude Code feedback as unresolved if not approved
            if self.config.claude_code_review and not claude_approved:
                unresolved_comments.extend(
                    {"body": feedback, "user": {"login": "claude-code"}}
                    for feedback in claude_feedback
                )

            if not changes_requested and not unresolved_comments:
                # No explicit approval but no blockers either - consider approved
                workflow_issue.status = IssueStatus.APPROVED
                return

            workflow_issue.status = IssueStatus.REVIEW_FIXING
            review_attempt += 1

            if progress_callback:
                await progress_callback(
                    f"issue_{workflow_issue.issue.number}",
                    "review_fixing",
                    {
                        "attempt": review_attempt,
                        "max_attempts": self.config.max_fix_attempts,
                        "human_comments": len(
                            [
                                c
                                for c in unresolved_comments
                                if c.get("user", {}).get("login") != "claude-code"
                            ]
                        ),
                        "claude_comments": len(claude_feedback) if not claude_approved else 0,
                    },
                )

            if review_attempt >= self.config.max_fix_attempts:
                workflow_issue.status = IssueStatus.FAILED
                return

            # Attempt to fix (implementation callback should handle this)
            await implementation_callback(workflow_issue.issue)

            # Commit and push fixes
            await self._commit_and_push_fix(workflow_issue, "fix: address review feedback")

            # Wait for CI again
            await self._wait_for_ci(workflow_issue, progress_callback)

            if workflow_issue.status == IssueStatus.CI_FAILED:
                # CI failed after fix - need to iterate on CI too
                ci_success = await self._iterate_ci(
                    workflow_issue, implementation_callback, progress_callback
                )
                if not ci_success:
                    workflow_issue.status = IssueStatus.FAILED
                    return

            # Brief pause before checking reviews again
            await asyncio.sleep(self.config.review_poll_interval)

        workflow_issue.status = IssueStatus.FAILED

    def _check_claude_code_review(
        self,
        reviews: list[dict[str, Any]],
        comments: list[dict[str, Any]],
    ) -> tuple[bool, list[str]]:
        """Check Claude Code review status from PR reviews and comments.

        Returns (is_approved, feedback_list).

        Claude Code reviews are identified by:
        - Reviews/comments from users matching claude patterns (claude-code, claude[bot])
        - Comments containing specific Claude Code review markers
        """
        claude_patterns = ["claude-code", "claude[bot]", "claude-code[bot]"]
        feedback: list[str] = []
        has_approval = False

        # Check reviews from Claude Code
        for review in reviews:
            user_login = review.get("user", {}).get("login", "").lower()
            if any(pattern in user_login for pattern in claude_patterns):
                state = review.get("state", "")
                if state == "APPROVED":
                    has_approval = True
                elif state == "CHANGES_REQUESTED":
                    body = review.get("body", "")
                    if body:
                        feedback.append(body)

        # Check comments from Claude Code
        for comment in comments:
            user_login = comment.get("user", {}).get("login", "").lower()
            if any(pattern in user_login for pattern in claude_patterns):
                body = comment.get("body", "")
                # Look for actionable feedback (not just acknowledgments)
                if body and self._is_actionable_feedback(body):
                    feedback.append(body)

        # If no Claude Code interaction yet, assume not approved (waiting for review)
        if not has_approval and not feedback:
            # Check if Claude Code review workflow has run
            # If it has run but no feedback, consider it approved
            return True, []

        return has_approval, feedback

    def _is_actionable_feedback(self, comment_body: str) -> bool:
        """Determine if a comment contains actionable feedback.

        Returns True if the comment suggests changes are needed.
        """
        # Indicators of actionable feedback
        action_indicators = [
            "should",
            "could",
            "consider",
            "suggest",
            "recommend",
            "fix",
            "change",
            "update",
            "modify",
            "refactor",
            "issue",
            "problem",
            "bug",
            "error",
            "mistake",
            "missing",
            "incomplete",
            "incorrect",
            "todo",
            "to do",
            "needs",
        ]

        # Indicators of approval/acknowledgment (not actionable)
        approval_indicators = [
            "lgtm",
            "looks good",
            "approved",
            "ship it",
            "great",
            "excellent",
            "perfect",
            "nice work",
        ]

        body_lower = comment_body.lower()

        # If it's clearly an approval, not actionable
        if any(indicator in body_lower for indicator in approval_indicators):
            return False

        # If it contains action indicators, it's actionable
        return any(indicator in body_lower for indicator in action_indicators)

    def _slugify(self, text: str) -> str:
        """Convert text to a URL-safe slug."""
        # Remove brackets and special chars
        text = re.sub(r"[\[\]()]", "", text)
        # Convert to lowercase and replace spaces
        text = text.lower().strip().replace(" ", "-")
        # Remove non-alphanumeric except dashes
        text = re.sub(r"[^a-z0-9-]", "", text)
        # Collapse multiple dashes
        text = re.sub(r"-+", "-", text)
        return text[:50]  # Limit length

    async def run_parallel(
        self,
        implementation_callback: Callable[[Issue], Coroutine[Any, Any, None]],
        progress_callback: ProgressCallback | None = None,
    ) -> None:
        """Run the workflow with parallel execution where possible."""
        while True:
            ready_issues = self.get_ready_issues()

            if not ready_issues:
                # Check if any issues are still in progress
                in_progress = [
                    i
                    for i in self.issues.values()
                    if i.status not in (IssueStatus.MERGED, IssueStatus.FAILED)
                ]
                if not in_progress:
                    break

                await asyncio.sleep(5)
                continue

            # Limit parallel execution
            batch = ready_issues[: self.config.parallel_branches]

            tasks = [
                self.work_on_issue(issue, implementation_callback, progress_callback)
                for issue in batch
            ]

            await asyncio.gather(*tasks)

    def get_status_summary(self) -> dict[str, Any]:
        """Get a summary of workflow status."""
        status_counts = {}
        for status in IssueStatus:
            status_counts[status.value] = sum(1 for i in self.issues.values() if i.status == status)

        return {
            "total_issues": len(self.issues),
            "status_counts": status_counts,
            "merged": status_counts.get("merged", 0),
            "failed": status_counts.get("failed", 0),
            "in_progress": sum(
                1
                for i in self.issues.values()
                if i.status not in (IssueStatus.MERGED, IssueStatus.FAILED, IssueStatus.QUEUED)
            ),
        }
