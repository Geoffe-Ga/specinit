"""GitHub workflow orchestration for issue-driven development."""

import asyncio
import re
import subprocess
from collections.abc import Callable, Coroutine
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any

from specinit.github.service import (
    GitHubService,
    Issue,
    PullRequest,
    create_branch,
    push_branch,
)

ProgressCallback = Callable[[str, str, dict | None], Coroutine[Any, Any, None]]


class IssueStatus(Enum):
    """Status of an issue in the workflow."""

    QUEUED = "queued"
    IN_PROGRESS = "in_progress"
    PR_CREATED = "pr_created"
    CI_RUNNING = "ci_running"
    CI_FAILED = "ci_failed"
    IN_REVIEW = "in_review"
    CHANGES_REQUESTED = "changes_requested"
    APPROVED = "approved"
    MERGED = "merged"
    BLOCKED = "blocked"
    FAILED = "failed"


@dataclass
class WorkflowIssue:
    """An issue being tracked in the workflow."""

    issue: Issue
    status: IssueStatus = IssueStatus.QUEUED
    branch_name: str = ""
    pr: PullRequest | None = None
    dependencies: list[int] = field(default_factory=list)
    fix_attempts: int = 0
    error_message: str = ""


@dataclass
class GitHubConfig:
    """Configuration for GitHub workflow."""

    owner: str
    repo: str
    base_branch: str = "main"
    auto_merge: bool = True
    yolo_mode: bool = False
    max_fix_attempts: int = 5
    parallel_branches: int = 3


class GitHubWorkflow:
    """Orchestrates issue-driven development workflow."""

    def __init__(
        self,
        config: GitHubConfig,
        project_path: Path,
        github_service: GitHubService | None = None,
    ) -> None:
        """Initialize the workflow."""
        self.config = config
        self.project_path = project_path
        self.github = github_service or GitHubService()
        self.issues: dict[int, WorkflowIssue] = {}
        self.milestone_number: int | None = None

    async def setup_repository(self) -> None:
        """Set up the repository with labels and milestone."""
        # Create labels
        labels = [
            ("specinit", "7057ff", "Generated by SpecInit"),
            ("automated", "0e8a16", "Automated PR"),
            ("setup", "c5def5", "Setup and configuration"),
            ("feature", "a2eeef", "New feature"),
            ("docs", "0075ca", "Documentation"),
            ("test", "d4c5f9", "Tests"),
            ("ci", "fbca04", "CI/CD"),
        ]

        for name, color, description in labels:
            self.github.create_label(self.config.owner, self.config.repo, name, color, description)

    async def create_milestone(self, title: str, description: str = "") -> int:
        """Create a milestone for the project."""
        self.milestone_number = self.github.create_milestone(
            self.config.owner, self.config.repo, title, description
        )
        return self.milestone_number

    async def create_issues_from_spec(
        self,
        _spec_content: str,
        features: list[str],
        user_story: dict[str, str],
    ) -> list[Issue]:
        """Create GitHub issues based on the product spec."""
        created_issues: list[Issue] = []

        # Standard setup issues
        setup_issues: list[tuple[str, str, list[str]]] = [
            (
                "[Setup] Initialize project structure",
                self._format_setup_issue_body(
                    "Create the initial directory structure and placeholder files."
                ),
                ["specinit", "automated", "setup"],
            ),
            (
                "[Docs] Create README and documentation",
                self._format_docs_issue_body(),
                ["specinit", "automated", "docs"],
            ),
            (
                "[Config] Configure linters and pre-commit hooks",
                self._format_config_issue_body(),
                ["specinit", "automated", "setup"],
            ),
            (
                "[CI] Set up GitHub Actions workflow",
                self._format_ci_issue_body(),
                ["specinit", "automated", "ci"],
            ),
        ]

        # Create setup issues
        for title, body, labels in setup_issues:
            issue = self.github.create_issue(
                self.config.owner,
                self.config.repo,
                title=title,
                body=body,
                labels=labels,
                milestone=self.milestone_number,
            )
            created_issues.append(issue)
            self.issues[issue.number] = WorkflowIssue(
                issue=issue,
                dependencies=[],
            )

        # Create feature issues
        setup_issue_numbers = [i.number for i in created_issues]
        for feature in features:
            issue = self.github.create_issue(
                self.config.owner,
                self.config.repo,
                title=f"[Feature] {feature}",
                body=self._format_feature_issue_body(feature, user_story),
                labels=["specinit", "automated", "feature"],
                milestone=self.milestone_number,
            )
            created_issues.append(issue)
            self.issues[issue.number] = WorkflowIssue(
                issue=issue,
                dependencies=setup_issue_numbers.copy(),
            )

        # Create final test issue (depends on features)
        feature_issue_numbers = [i.number for i in created_issues if "[Feature]" in i.title]
        test_issue = self.github.create_issue(
            self.config.owner,
            self.config.repo,
            title="[Test] Write integration tests",
            body=self._format_test_issue_body(features),
            labels=["specinit", "automated", "test"],
            milestone=self.milestone_number,
        )
        created_issues.append(test_issue)
        self.issues[test_issue.number] = WorkflowIssue(
            issue=test_issue,
            dependencies=feature_issue_numbers,
        )

        return created_issues

    def _format_setup_issue_body(self, description: str) -> str:
        """Format setup issue body."""
        return f"""## Initialize Project Structure

### Description
{description}

### Tasks
- [ ] Create directory tree per template
- [ ] Add .gitignore
- [ ] Create plan/ directory with spec files
- [ ] Add package.json / pyproject.toml

### Acceptance Criteria
- All directories exist
- No linter errors on structure
- plan/product-spec.md present
"""

    def _format_docs_issue_body(self) -> str:
        """Format documentation issue body."""
        return """## Create Documentation

### Description
Write comprehensive documentation for the project.

### Tasks
- [ ] Create README.md with quick start guide
- [ ] Create CONTRIBUTING.md with development workflow
- [ ] Create CLAUDE.md with AI context
- [ ] Add architecture documentation

### Acceptance Criteria
- README includes installation and usage
- Contributing guide covers testing workflow
- CLAUDE.md documents key decisions
"""

    def _format_config_issue_body(self) -> str:
        """Format config issue body."""
        return """## Configure Developer Tooling

### Description
Set up linters, formatters, and pre-commit hooks.

### Tasks
- [ ] Configure ESLint/Ruff
- [ ] Configure Prettier/Black
- [ ] Set up pre-commit hooks
- [ ] Verify all tools work together

### Acceptance Criteria
- Linters pass on all files
- Pre-commit hooks run successfully
- Tools are properly integrated
"""

    def _format_ci_issue_body(self) -> str:
        """Format CI issue body."""
        return """## Set Up CI/CD

### Description
Configure GitHub Actions for continuous integration.

### Tasks
- [ ] Create CI workflow for tests
- [ ] Create workflow for linting
- [ ] Configure caching for dependencies
- [ ] Add status badges to README

### Acceptance Criteria
- CI runs on all PRs
- Tests and linters execute
- Workflows complete successfully
"""

    def _format_feature_issue_body(self, feature: str, user_story: dict[str, str]) -> str:
        """Format feature issue body."""
        return f"""## Implement: {feature}

### Description
Implement the {feature} feature.

### User Story
As {user_story.get("role", "a user")}, I want to {user_story.get("action", "use this feature")}, so that {user_story.get("outcome", "I can achieve my goal")}.

### Tasks
- [ ] Write tests first (TDD)
- [ ] Implement feature
- [ ] Update documentation
- [ ] Verify all tests pass

### Acceptance Criteria
- Feature works as described
- Tests cover happy path and edge cases
- Documentation updated
"""

    def _format_test_issue_body(self, features: list[str]) -> str:
        """Format test issue body."""
        feature_list = "\n".join(f"- {f}" for f in features)
        return f"""## Write Integration Tests

### Description
Create comprehensive integration tests for all features.

### Features to Test
{feature_list}

### Tasks
- [ ] Write end-to-end tests
- [ ] Test feature interactions
- [ ] Test error scenarios
- [ ] Achieve coverage targets

### Acceptance Criteria
- All integration tests pass
- Coverage meets targets
- Error scenarios handled
"""

    def get_ready_issues(self) -> list[WorkflowIssue]:
        """Get issues that are ready to be worked on."""
        ready = []

        for workflow_issue in self.issues.values():
            if workflow_issue.status != IssueStatus.QUEUED:
                continue

            # Check if all dependencies are merged
            deps_satisfied = all(
                self.issues.get(dep, WorkflowIssue(issue=Issue(0, "", "", []))).status
                == IssueStatus.MERGED
                for dep in workflow_issue.dependencies
            )

            if deps_satisfied:
                ready.append(workflow_issue)

        return ready

    async def work_on_issue(
        self,
        workflow_issue: WorkflowIssue,
        implementation_callback: Callable[[Issue], Coroutine[Any, Any, None]],
        progress_callback: ProgressCallback | None = None,
    ) -> None:
        """Work on a single issue through the full workflow."""
        issue = workflow_issue.issue
        workflow_issue.status = IssueStatus.IN_PROGRESS

        if progress_callback:
            await progress_callback(
                f"issue_{issue.number}",
                "in_progress",
                {"title": issue.title},
            )

        # Create branch
        branch_name = f"issue-{issue.number}-{self._slugify(issue.title)}"
        workflow_issue.branch_name = branch_name

        try:
            create_branch(branch_name, self.config.base_branch)
        except subprocess.CalledProcessError:
            # Branch might already exist
            subprocess.run(["git", "checkout", branch_name], check=True)

        # Implementation (provided by caller)
        await implementation_callback(issue)

        # Run pre-commit
        precommit_success = await self._run_precommit(workflow_issue)
        if not precommit_success and workflow_issue.fix_attempts >= self.config.max_fix_attempts:
            workflow_issue.status = IssueStatus.FAILED
            return

        # Commit and push
        subprocess.run(
            ["git", "add", "."],
            cwd=self.project_path,
            check=True,
        )
        subprocess.run(
            [
                "git",
                "commit",
                "-m",
                f"feat: {issue.title}\n\nCloses #{issue.number}",
            ],
            cwd=self.project_path,
            check=True,
        )
        push_branch(branch_name)

        # Create PR
        pr = self.github.create_pull_request(
            self.config.owner,
            self.config.repo,
            title=issue.title.replace("[", "").replace("]", ": ").strip(),
            body=f"## Summary\n\n{issue.body}\n\nCloses #{issue.number}",
            head=branch_name,
            base=self.config.base_branch,
        )
        workflow_issue.pr = pr
        workflow_issue.status = IssueStatus.PR_CREATED

        if progress_callback:
            await progress_callback(
                f"issue_{issue.number}",
                "pr_created",
                {"pr_url": pr.url, "pr_number": pr.number},
            )

        # Wait for CI
        await self._wait_for_ci(workflow_issue, progress_callback)

        # If YOLO mode, handle reviews
        if self.config.yolo_mode:
            await self._handle_reviews(workflow_issue, implementation_callback, progress_callback)

        # Merge if ready
        if self.config.auto_merge and workflow_issue.status == IssueStatus.APPROVED:
            success = self.github.merge_pull_request(
                self.config.owner,
                self.config.repo,
                pr.number,
            )
            if success:
                workflow_issue.status = IssueStatus.MERGED
                if progress_callback:
                    await progress_callback(
                        f"issue_{issue.number}",
                        "merged",
                        {"pr_number": pr.number},
                    )

    async def _run_precommit(self, workflow_issue: WorkflowIssue) -> bool:
        """Run pre-commit hooks and return success status."""
        result = subprocess.run(
            ["pre-commit", "run", "--all-files"],
            cwd=self.project_path,
            capture_output=True,
            text=True,
            check=False,
        )

        if result.returncode == 0:
            return True

        workflow_issue.fix_attempts += 1
        workflow_issue.error_message = result.stdout + result.stderr
        return False

    async def _wait_for_ci(
        self,
        workflow_issue: WorkflowIssue,
        progress_callback: ProgressCallback | None = None,
    ) -> None:
        """Wait for CI checks to complete."""
        workflow_issue.status = IssueStatus.CI_RUNNING
        pr = workflow_issue.pr
        if not pr:
            return

        if progress_callback:
            await progress_callback(
                f"issue_{workflow_issue.issue.number}",
                "ci_running",
                {"pr_number": pr.number},
            )

        max_wait = 600  # 10 minutes
        interval = 15
        elapsed = 0

        while elapsed < max_wait:
            checks = self.github.get_pr_checks(
                self.config.owner, self.config.repo, workflow_issue.branch_name
            )

            check_runs = checks.get("check_runs", [])
            if not check_runs:
                await asyncio.sleep(interval)
                elapsed += interval
                continue

            all_complete = all(run.get("status") == "completed" for run in check_runs)
            all_success = all(run.get("conclusion") in ("success", "skipped") for run in check_runs)

            if all_complete:
                if all_success:
                    workflow_issue.status = IssueStatus.IN_REVIEW
                    return
                else:
                    workflow_issue.status = IssueStatus.CI_FAILED
                    if progress_callback:
                        await progress_callback(
                            f"issue_{workflow_issue.issue.number}",
                            "ci_failed",
                            {"pr_number": pr.number},
                        )
                    return

            await asyncio.sleep(interval)
            elapsed += interval

        workflow_issue.status = IssueStatus.CI_FAILED

    async def _handle_reviews(
        self,
        workflow_issue: WorkflowIssue,
        implementation_callback: Callable[[Issue], Coroutine[Any, Any, None]],
        progress_callback: ProgressCallback | None = None,
    ) -> None:
        """Handle review comments in YOLO mode."""
        pr = workflow_issue.pr
        if not pr:
            return

        while workflow_issue.fix_attempts < self.config.max_fix_attempts:
            # Get reviews and comments
            reviews = self.github.get_pr_reviews(self.config.owner, self.config.repo, pr.number)
            comments = self.github.get_pr_comments(self.config.owner, self.config.repo, pr.number)

            # Check if approved
            approved = any(r.get("state") == "APPROVED" for r in reviews)
            if approved:
                workflow_issue.status = IssueStatus.APPROVED
                return

            # Check for change requests
            changes_requested = any(r.get("state") == "CHANGES_REQUESTED" for r in reviews)
            unresolved_comments = [c for c in comments if not c.get("resolved", False)]

            if not changes_requested and not unresolved_comments:
                # No explicit approval but no blockers either
                workflow_issue.status = IssueStatus.APPROVED
                return

            workflow_issue.status = IssueStatus.CHANGES_REQUESTED

            if progress_callback:
                await progress_callback(
                    f"issue_{workflow_issue.issue.number}",
                    "resolving_feedback",
                    {"comments": len(unresolved_comments)},
                )

            # Attempt to fix (implementation callback should handle this)
            await implementation_callback(workflow_issue.issue)
            workflow_issue.fix_attempts += 1

            # Commit and push fixes
            subprocess.run(["git", "add", "."], cwd=self.project_path, check=True)
            subprocess.run(
                ["git", "commit", "-m", "fix: address review feedback"],
                cwd=self.project_path,
                check=False,
            )
            push_branch(workflow_issue.branch_name, force=False)

            # Wait for CI again
            await self._wait_for_ci(workflow_issue, progress_callback)

            if workflow_issue.status == IssueStatus.CI_FAILED:
                break

            await asyncio.sleep(5)  # Brief pause before checking reviews again

        if workflow_issue.fix_attempts >= self.config.max_fix_attempts:
            workflow_issue.status = IssueStatus.FAILED

    def _slugify(self, text: str) -> str:
        """Convert text to a URL-safe slug."""
        # Remove brackets and special chars
        text = re.sub(r"[\[\]()]", "", text)
        # Convert to lowercase and replace spaces
        text = text.lower().strip().replace(" ", "-")
        # Remove non-alphanumeric except dashes
        text = re.sub(r"[^a-z0-9-]", "", text)
        # Collapse multiple dashes
        text = re.sub(r"-+", "-", text)
        return text[:50]  # Limit length

    async def run_parallel(
        self,
        implementation_callback: Callable[[Issue], Coroutine[Any, Any, None]],
        progress_callback: ProgressCallback | None = None,
    ) -> None:
        """Run the workflow with parallel execution where possible."""
        while True:
            ready_issues = self.get_ready_issues()

            if not ready_issues:
                # Check if any issues are still in progress
                in_progress = [
                    i
                    for i in self.issues.values()
                    if i.status not in (IssueStatus.MERGED, IssueStatus.FAILED)
                ]
                if not in_progress:
                    break

                await asyncio.sleep(5)
                continue

            # Limit parallel execution
            batch = ready_issues[: self.config.parallel_branches]

            tasks = [
                self.work_on_issue(issue, implementation_callback, progress_callback)
                for issue in batch
            ]

            await asyncio.gather(*tasks)

    def get_status_summary(self) -> dict[str, Any]:
        """Get a summary of workflow status."""
        status_counts = {}
        for status in IssueStatus:
            status_counts[status.value] = sum(1 for i in self.issues.values() if i.status == status)

        return {
            "total_issues": len(self.issues),
            "status_counts": status_counts,
            "merged": status_counts.get("merged", 0),
            "failed": status_counts.get("failed", 0),
            "in_progress": sum(
                1
                for i in self.issues.values()
                if i.status not in (IssueStatus.MERGED, IssueStatus.FAILED, IssueStatus.QUEUED)
            ),
        }
